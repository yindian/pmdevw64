diff --git a/src/Makefile b/src/Makefile
new file mode 100644
index 0000000..e0acad1
--- /dev/null
+++ b/src/Makefile
@@ -0,0 +1,92 @@
+# created from autogenerated Makefile
+RX = ../../regex-alpha3.8p1
+CURSES= ../../PDCurses-3.8
+LEX = flex
+YACC = bison -y
+
+#----------------------
+CC = gcc
+LD = $(CC)
+STRIP = strip
+SOURCES = fscanner.l egrep.y alloc.c basename.c build.c build.h command.c compath.c constants.h crossref.c dir.c 	display.c edit.c exec.c find.c global.h help.c history.c input.c 	invlib.c invlib.h library.h logdir.c lookup.c lookup.h main.c mouse.c mygetenv.c mypopen.c scanner.h version.h vp.h vpaccess.c vpfopen.c vpinit.c vpopen.c
+CLEANFILES = fscanner.c egrep.c
+CONFIG_HEADER = config.h
+PROGRAM = cscope.exe
+
+ifeq ($(DEBUG),Y)
+CFLAGS = -O0 -g
+else
+CFLAGS = -O2
+endif
+CFLAGS += -DHAVE_CONFIG_H -DWIN32 -I. -I$(RX) -I$(CURSES)
+LDFLAGS = $(CURSES)/wincon/pdcurses.a $(RX)/libregex.a
+
+OBJECTS =  fscanner.o egrep.o alloc.o basename.o \
+build.o command.o compath.o crossref.o dir.o display.o \
+edit.o exec.o find.o help.o history.o input.o invlib.o \
+logdir.o lookup.o main.o mouse.o mygetenv.o mypopen.o \
+w32utils.o vpaccess.o vpfopen.o vpinit.o vpopen.o
+
+.SUFFIXES:
+.SUFFIXES: .c .l .o .y
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) -c $(CFLAGS) $<
+
+$(PROGRAM): $(OBJECTS)
+	$(LD) $(OBJECTS) $(LDFLAGS) -o $(PROGRAM)
+.l.c:
+	$(LEX) -o$*.c $*.l
+.y.c:
+	$(YACC) -o$*.c $*.y
+egrep.h: egrep.c
+
+alloc.o: alloc.c library.h global.h config.h constants.h invlib.h
+basename.o: basename.c global.h config.h constants.h invlib.h \
+	library.h
+build.o: build.c build.h global.h config.h constants.h invlib.h \
+	library.h scanner.h version.h vp.h  w32utils.h
+command.o: command.c global.h config.h constants.h invlib.h library.h \
+	build.h w32utils.h
+compath.o: compath.c global.h config.h constants.h invlib.h library.h w32utils.h
+crossref.o: crossref.c global.h config.h constants.h invlib.h \
+	library.h build.h scanner.h  w32utils.h
+dir.o: dir.c global.h config.h constants.h invlib.h library.h vp.h w32utils.h
+display.o: display.c global.h config.h constants.h invlib.h library.h \
+	build.h version.h w32utils.h
+edit.o: edit.c global.h config.h constants.h invlib.h library.h
+egrep.o: egrep.c global.h config.h constants.h invlib.h library.h
+exec.o: exec.c global.h config.h constants.h invlib.h library.h
+find.o: find.c global.h config.h constants.h invlib.h library.h \
+	build.h scanner.h w32utils.h
+fscanner.o: fscanner.c global.h config.h constants.h invlib.h \
+	library.h scanner.h lookup.h
+help.o: help.c global.h config.h constants.h invlib.h library.h
+history.o: history.c global.h config.h constants.h invlib.h library.h
+input.o: input.c global.h config.h constants.h invlib.h library.h
+invlib.o: invlib.c invlib.h global.h config.h constants.h library.h
+logdir.o: logdir.c global.h config.h constants.h invlib.h library.h
+lookup.o: lookup.c global.h config.h constants.h invlib.h library.h \
+	lookup.h
+main.o: main.c global.h config.h constants.h invlib.h library.h \
+	build.h vp.h version.h scanner.h
+mouse.o: mouse.c global.h config.h constants.h invlib.h library.h
+mygetenv.o: mygetenv.c library.h
+mypopen.o: mypopen.c global.h config.h constants.h invlib.h library.h
+w32utils.o: w32utils.h w32utils.c alloc.h
+vpaccess.o: vpaccess.c vp.h config.h
+vpfopen.o: vpfopen.c vp.h config.h global.h constants.h invlib.h \
+	library.h
+vpinit.o: vpinit.c vp.h config.h library.h global.h constants.h \
+	invlib.h
+vpopen.o: vpopen.c global.h config.h constants.h invlib.h library.h \
+	vp.h
+
+clean:
+	rm -f $(OBJECTS) fscanner.c egrep.c $(PROGRAM)
+
+dist:	$(PROGRAM)
+	$(STRIP) cscope.exe
+	7z a -tzip -mx=9 cscope.zip $(PROGRAM) sort.exe
diff --git a/src/basename.c b/src/basename.c
index 3ab9be1..0b92193 100644
--- a/src/basename.c
+++ b/src/basename.c
@@ -34,6 +34,18 @@
 
 #include "global.h"
 
+#ifdef WIN32
+char *
+mybasename(char *path)
+{
+	char	*s1, *s2;
+	s2 = strrchr(path, '\\');
+	if ((s1 = strrchr(path, '/')) != 0 || s2 != 0){
+		return( (s1>s2?s1:s2) + 1 ); /* don't use max ;)) */
+	}
+	return(path);
+}
+#else
 char *
 mybasename(char *path)
 {
@@ -44,3 +56,4 @@ mybasename(char *path)
 	}
 	return(path);
 }
+#endif
diff --git a/src/build.c b/src/build.c
index a32b5cb..4218a14 100644
--- a/src/build.c
+++ b/src/build.c
@@ -52,6 +52,8 @@
 #include <curses.h>
 #endif
 
+#include "w32utils.h"
+
 /* Exported variables: */
 
 BOOL	buildonly = NO;		/* only build the database */
@@ -216,6 +218,10 @@ build(void)
     int     copied = 0;		/* copied crossref for these files */
     unsigned long fileindex;		/* source file name index */
     BOOL    interactive = YES;	/* output progress messages */
+    static char* signature;
+    signature = (whitespace_safe
+    	? "cscope %d %" PATHLEN_STR "[^\"]s" 
+    	: "cscope %d %" PATHLEN_STR "s");
 
     /* normalize the current directory relative to the home directory so
        the cross-reference is not rebuilt when the user's login is moved */
@@ -232,9 +238,12 @@ build(void)
     /* or this is an unconditional build */
     if ((oldrefs = vpfopen(reffile, "rb")) != NULL
 	&& unconditional == NO
-	&& fscanf(oldrefs, "cscope %d %" PATHLEN_STR "s", &fileversion, olddir) == 2 
+	&& fscanf(oldrefs, signature, &fileversion, olddir) == 2 
 	&& (strcmp(olddir, currentdir) == 0 /* remain compatible */
+	    || (!whitespace_safe && strcmp(olddir, get_shortpath(currentdir)) == 0)
 	    || strcmp(olddir, newdir) == 0)) {
+	        if (whitespace_safe)
+	            fgetc(oldrefs); /* remove our mark */
 	/* get the cross-reference file's modification time */
 	fstat(fileno(oldrefs), &statstruct);
 	reftime = statstruct.st_mtime;
@@ -454,7 +463,11 @@ cscope: converting to new symbol database file format\n");
 	}
 	fstat(fileno(postings), &statstruct);
 	fclose(postings);
+#ifdef WIN32
+	snprintf(sortcommand, sizeof(sortcommand), "set LC_ALL=C && sort -T %s %s", tmpdir, temp1);
+#else	
 	snprintf(sortcommand, sizeof(sortcommand), "env LC_ALL=C sort -T %s %s", tmpdir, temp1);
+#endif
 	if ((postings = mypopen(sortcommand, "r")) == NULL) {
 	    fprintf(stderr, "cscope: cannot open pipe to sort command\n");
 	    cannotindex();
@@ -549,7 +562,16 @@ void free_newbuildfiles(void)
 static void
 putheader(char *dir)
 {
-    dboffset = fprintf(newrefs, "cscope %d %s", FILEVERSION, dir);
+    const char *signature = (whitespace_safe
+		? "cscope %d %s\""
+		: "cscope %d %s");
+#ifdef WIN32
+    /* get 8.3 name for -X command line option
+     * so it should work with long file paths anyway */
+    if (!whitespace_safe)
+	dir = get_shortpath(dir);
+#endif
+    dboffset = fprintf(newrefs, signature, FILEVERSION, dir);
     if (compress == NO) {
 	dboffset += fprintf(newrefs, " -c");
     }
diff --git a/src/command.c b/src/command.c
index 8740b11..0f6f997 100644
--- a/src/command.c
+++ b/src/command.c
@@ -47,6 +47,8 @@
 #endif
 #include <ctype.h>
 
+#include "w32utils.h"
+
 int	selecting;
 unsigned int   curdispline = 0;
 
@@ -906,6 +908,7 @@ countrefs(void)
 	    disprefs = 0;
 	    return;
 	}
+	to_longpath(file, sizeof(file));
 	if ((i = strlen(pathcomponents(file, dispcomponents))) > filelen) {
 	    filelen = i;
 	}
diff --git a/src/compath.c b/src/compath.c
index 037d341..e62f26f 100644
--- a/src/compath.c
+++ b/src/compath.c
@@ -64,7 +64,11 @@ compath(char *pathname)			/*FDEF*/
 		 *	do not change the path if it has no "/"
 		 */
 
-	if (strchr(pathname, '/') == NULL)
+	if (strchr(pathname, '/') == NULL 
+#ifdef WIN32
+		&& strchr(pathname, '\\') == NULL
+#endif
+		)
 		return(pathname);
 
 		/*
@@ -72,7 +76,13 @@ compath(char *pathname)			/*FDEF*/
 		 */
 
 	for (lastchar = pathname + 1; *lastchar != '\0'; lastchar++)
-		if ((*lastchar == '/') && (*(lastchar - 1) == '/'))
+		if ((*lastchar == '/') && (*(lastchar - 1) == '/')
+#ifdef WIN32
+			||(*lastchar == '\\') && (*(lastchar - 1) == '/')
+			||(*lastchar == '\\') && (*(lastchar - 1) == '\\')
+			||(*lastchar == '/') && (*(lastchar - 1) == '\\')
+#endif
+			)
 		{
 
 			/*
@@ -80,7 +90,11 @@ compath(char *pathname)			/*FDEF*/
 			 */
 
 			nextchar = lastchar;
-			while (*++lastchar == '/')
+			while (*++lastchar == '/'
+#ifdef WIN32
+			    || *++lastchar == '\\'
+#endif
+				)
 			{
 			}
 
@@ -100,8 +114,17 @@ compath(char *pathname)			/*FDEF*/
 		 */
 
 	for (lastchar = pathname + 1; *lastchar != '\0'; lastchar++)
+#ifdef WIN32 
+		if (((*lastchar == '/') || (*lastchar == '\\'))
+		    && (*(lastchar - 1) == '.')
+		    && ((lastchar - 1 == pathname) 
+		     || (*(lastchar - 2) == '/')
+		     || (*(lastchar - 2) == '\\'))
+		    )
+#else
 		if ((*lastchar == '/') && (*(lastchar - 1) == '.') &&
 		    ((lastchar - 1 == pathname) || (*(lastchar - 2) == '/')))
+#endif
 		{
 
 			/*
@@ -120,9 +143,18 @@ compath(char *pathname)			/*FDEF*/
 		 */
 
 	for (lastchar = pathname + 1; *lastchar != '\0'; lastchar++)
+#ifdef WIN32
+		if ((lastchar != pathname)
+			&& ((*lastchar == '/') || (*lastchar == '\\'))
+			&& (*(lastchar + 1) == '.') && (*(lastchar + 2) == '.')
+			&& ((*(lastchar + 3) == '/') 
+			    || (*(lastchar + 3) == '\\')
+			    || (*(lastchar + 3) == '\0')))
+#else
 		if ((lastchar != pathname) && (*lastchar == '/') &&
 		    (*(lastchar + 1) == '.') && (*(lastchar + 2) == '.') &&
 		    ((*(lastchar + 3) == '/') || (*(lastchar + 3) == '\0')))
+#endif
 		{
 
 			/*
@@ -131,7 +163,11 @@ compath(char *pathname)			/*FDEF*/
 
 			nextchar = lastchar - 1;
 			while ((nextchar != pathname) &&
-			    (*(nextchar - 1) != '/'))
+			    (*(nextchar - 1) != '/')
+#ifdef WIN32
+			    && (*(nextchar - 1) != '\\')
+#endif
+			    )
 				--nextchar;
 
 			/*
@@ -141,7 +177,17 @@ compath(char *pathname)			/*FDEF*/
 
 			if ((*nextchar == '.') &&
 			    ((*(nextchar + 1) == '/') ||
-			     ((*(nextchar + 1) == '.') && (*(nextchar + 2) == '/'))))
+#ifdef WIN32
+			     (*(nextchar + 1) == '\\') ||
+#endif
+			     ((*(nextchar + 1) == '.') && 
+#ifdef WIN32
+				((*(nextchar + 2) == '/') || (*(nextchar + 2) == '\\'))
+#else
+				  (*(nextchar + 2) == '/')
+#endif
+			      )
+			     ))
 				/* EMPTY */;
 			else
 			{
@@ -151,7 +197,11 @@ compath(char *pathname)			/*FDEF*/
 				 *	"dir_name/../" or "dir_name/.."
 				 */
 
+#ifdef WIN32
+				if ((*(lastchar + 3) == '/') || (*(lastchar + 3) == '\\'))
+#else
 				if (*(lastchar + 3) == '/')
+#endif
 					lastchar += 4;
 				else
 					lastchar += 3;
@@ -172,7 +222,13 @@ compath(char *pathname)			/*FDEF*/
 				 *	slash is part of "/.."
 				 */
 
-				if ((sofar + 1 != pathname) && (*sofar == '/'))
+				if ((sofar + 1 != pathname) && 
+#ifdef WIN32
+					((*sofar == '/') || (*sofar == '\\'))
+#else
+					(*sofar == '/')
+#endif
+					)
 					--lastchar;
 			}
 		}
@@ -185,7 +241,11 @@ compath(char *pathname)			/*FDEF*/
 	pnlen = strlen(pathname);
 	pnend = strchr(pathname, '\0') - 1;
 
+#ifdef WIN32
+	if ((pnlen > 1) && ((*pnend == '/') || (*pnend == '\\')))
+#else
 	if ((pnlen > 1) && (*pnend == '/'))
+#endif
 	{
 		*pnend-- = '\0';
 		pnlen--;
@@ -196,7 +256,13 @@ compath(char *pathname)			/*FDEF*/
 	 *	"/.", remove the "/.".
 	 */
 
-	if ((pnlen > 2) && (*(pnend - 1) == '/') && (*pnend == '.'))
+	if ((pnlen > 2) &&
+#ifdef WIN32
+		((*(pnend - 1) == '/') || (*(pnend - 1) == '\\')) &&
+#else
+		(*(pnend - 1) == '/') &&
+#endif
+		(*pnend == '.'))
 		*--pnend = '\0';
 
 	/*
diff --git a/src/config.h b/src/config.h
new file mode 100644
index 0000000..b6f9772
--- /dev/null
+++ b/src/config.h
@@ -0,0 +1,106 @@
+/* config.h.  Created from autogenerated config.h  */
+
+#define PACKAGE "cscope"
+#define VERSION "15.8a"
+
+/* Found some version of curses that we're going to use */
+#define HAS_CURSES 1
+
+/* Use SystemV curses? */
+#define USE_SYSV_CURSES 1
+
+/* Define if you have the <dirent.h> header file, and it defines `DIR'. */
+#define HAVE_DIRENT_H 1
+
+/* Define if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the `fixkeypad' function. */
+/* #undef HAVE_FIXKEYPAD */
+
+/* Define if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have the `regex' library (-lregex). */
+#define HAVE_LIBREGEX 1
+
+/* Define if you have the `lstat' function. */
+/* #undef HAVE_LSTAT */
+
+/* Define if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define if you have the `memset' function. */
+#define HAVE_MEMSET 1
+
+/* Define if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the `regcmp' function. */
+/* #undef HAVE_REGCMP */
+
+/* Define if you have the `regcomp' function. */
+#define HAVE_REGCOMP 1
+
+/* Define if you have the `setmode' function. */
+#define HAVE_SETMODE 1
+
+/* Define if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <sys/dir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if you have the <sys/ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define if you have the <sys/termios.h> header file. */
+/* #undef HAVE_SYS_TERMIOS_H */
+
+/* Define if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define if you have the <sys/window.h> header file. */
+/* #undef HAVE_SYS_WINDOW_H */
+
+/* Define if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define if you have the `_setmode' function. */
+#define HAVE__SETMODE 1
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define if you have the ANSI C header files. */
+#define STDC_HEADERS 1
diff --git a/src/crossref.c b/src/crossref.c
index 549bc6a..8342cac 100644
--- a/src/crossref.c
+++ b/src/crossref.c
@@ -45,6 +45,8 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 
+#include "w32utils.h"
+
 /* convert long to a string in base BASE notation */
 #define	ltobase(value)                     \
 do {                                       \
diff --git a/src/dir.c b/src/dir.c
index 01c599e..e795cf2 100644
--- a/src/dir.c
+++ b/src/dir.c
@@ -45,8 +45,17 @@
 #include <dirent.h>
 #include <sys/stat.h>	/* stat */
 #include <assert.h>
+#ifdef MSVC_WIN32
+#include <direct.h>	/* getcwd */
+#endif
 
+#include "w32utils.h"
+
+#ifdef WIN32
+#define	DIRSEPS	" ,;"
+#else
 #define	DIRSEPS	" ,:"	/* directory list separators */
+#endif
 #define	DIRINC	10	/* directory list size increment */
 #define HASHMOD	2003	/* must be a prime number */
 #define	SRCINC	HASHMOD	/* source file list size increment */
@@ -135,7 +144,11 @@ sourcedir(char *dirlist)
 
 	/* if it isn't a full path name and there is a 
 	   multi-directory view path */
-	if (*dirlist != '/' && vpndirs > 1) {
+		if (*dirlist != '/'
+#ifdef WIN32
+			&& *dirlist != '\\' && *dirlist != '\0' && dirlist[1] != ':'
+#endif
+			&& vpndirs > 1) {
 			
 	    /* compute its path from higher view path source dirs */
 	    for (i = 1; i < nvpsrcdirs; ++i) {
@@ -203,7 +216,11 @@ includedir(char *dirlist)
 
 	/* if it isn't a full path name and there is a 
 	   multi-directory view path */
-	if (*dirlist != '/' && vpndirs > 1) {
+	if (*dirlist != '/' 
+#ifdef WIN32
+			&& *dirlist != '\\' && *dirlist != '\0' && dirlist[1] != ':'
+#endif
+			&& vpndirs > 1) {
 			
 	    /* compute its path from higher view path source dirs */
 	    for (i = 1; i < nvpsrcdirs; ++i) {
@@ -672,8 +689,12 @@ inviewpath(char *file)
 
     /* if it isn't a full path name and there is a multi-directory
      * view path */
-    if (*file != '/' && vpndirs > 1) {
-	int file_len = strlen(file);
+	if (*file != '/' 
+#ifdef WIN32
+		&& *file != '\\' && *file != '\0' && file[1] != ':'
+#endif
+		&& vpndirs > 1) {
+		int file_len = strlen(file);
 
 	/* compute its path from higher view path source dirs */
 	for (i = 1; i < nvpsrcdirs; ++i) {
@@ -702,9 +723,9 @@ addsrcfile(char *path)
 		srcfiles = myrealloc(srcfiles, msrcfiles * sizeof(*srcfiles));
 	}
 	/* add the file to the list */
-	srcfiles[nsrcfiles++] = my_strdup(compath(path));
+	srcfiles[nsrcfiles++] = my_strdup(compath(get_shortpath(path)));
 	p = mymalloc(sizeof(*p));
-	p->text = my_strdup(compath(path));
+	p->text = my_strdup(compath(get_shortpath(path)));
 	i = hash(p->text) % HASHMOD;
 	p->next = srcnames[i];
 	srcnames[i] = p;
diff --git a/src/display.c b/src/display.c
index 01bac86..ab2024d 100644
--- a/src/display.c
+++ b/src/display.c
@@ -56,6 +56,8 @@
 #include <errno.h>
 #include <stdarg.h>
 
+#include "w32utils.h"
+
 #ifndef HAVE_SIGSETJMP
 # define sigsetjmp(a,b) setjmp(a)
 # define siglongjmp(a,b) longjmp(a,b)
@@ -154,9 +156,14 @@ display(void)
     int     i;
     char    *s;
 
-    /* see if this is the initial display */
-    erase();
-    if (refsfound == NULL) {
+	/* see if this is the initial display */
+	erase();
+ 
+#if defined(WIN32) && defined(__PDCURSES__)
+	PDC_resize_screen(LINES, COLS); /* Fix if user have changed the screen buffer size */
+ #endif
+
+	if (refsfound == NULL) {
 #if CCS
 	if (displayversion == YES) {
 	    printw("cscope %s", ESG_REL);
@@ -245,6 +252,7 @@ display(void)
 		addch(' ');
 	    }
 
+	    to_longpath(file, sizeof(file));
 	    /* display the file name */
 	    if (field == FILENAME) {
 		printw("%-*s ", filelen, file);
@@ -729,14 +737,22 @@ pathcomponents(char *path, int components)
 {
 	int	i;
 	char	*s;
-	
+
 	s = path + strlen(path) - 1;
 	for (i = 0; i < components; ++i) {
-		while (s > path && *--s != '/') {
+		while (s > path && *--s != '/'
+#ifdef WIN32
+			&& *s != '\\'
+#endif
+			) {
 			;
 		}
 	}
+#ifdef WIN32
+	if (s > path && (*s == '/' || *s == '\\')){
+#else
 	if (s > path && *s == '/') {
+#endif
 		++s;
 	}
 	return(s);
diff --git a/src/edit.c b/src/edit.c
index 0478bb3..e6d3583 100644
--- a/src/edit.c
+++ b/src/edit.c
@@ -129,7 +129,11 @@ filepath(char *file)
 {
 	static	char	path[PATHLEN + 1];
 	
-	if (prependpath != NULL && *file != '/') {
+	if (prependpath != NULL && *file != '/'
+#ifdef WIN32
+		&& *file != '\\' && *file != '\0' && file[1] != ':'
+#endif
+		) {
 		(void) snprintf(path, sizeof(path), "%s/%s", prependpath, file);
 		file = path;
 	}
diff --git a/src/exec.c b/src/exec.c
index 7b116ad..0c9d8fa 100644
--- a/src/exec.c
+++ b/src/exec.c
@@ -37,8 +37,11 @@
 
 #include <unistd.h>
 #include "global.h"
+#include "alloc.h"
 #include <stdarg.h>
+#ifndef WIN32
 #include <sys/wait.h>
+#endif
 #include <sys/types.h>      /* pid_t */
 #ifdef __DJGPP__
 #include <process.h>
@@ -53,7 +56,7 @@ static	sighandler_t oldsigquit; /* old value of quit signal */
 static	sighandler_t oldsighup; /* old value of hangup signal */
 static	sighandler_t oldsigtstp; /* old value of SIGTSTP */
 
-#ifndef __MSDOS__ /* none of these is needed, there */
+#if !defined(__MSDOS__) && !defined(WIN32) /* none of these is needed, there */
 static	int	join(pid_t p);
 static	int	myexecvp(char *a, char **args);
 static	pid_t	myfork(void);
@@ -79,10 +82,20 @@ execute(char *a, ...)	/* note: "exec" is already defined on u370 */
 	va_start(ap, a);
 	for (p = 0; (argv[p] = va_arg(ap, char *)) != 0; p++)
 		;
-#ifdef __MSDOS__
+#if defined(__MSDOS__) || defined(WIN32)
 	/* HBB 20010313: in MSDOG, everything is completely different.
 	 * No fork()/exec()/wait(), but rather a single libc call: */
-        exitcode = spawnvp(P_WAIT, a, argv);
+	if (a[0] == '"' && a[strlen(a)-1] == '"')
+	{
+	    char	*exename;
+	    /* executable name is delimited by quotes */
+	    exename = my_strdup(a+1);
+	    exename[strlen(exename)-1] = '\0';
+	    exitcode = spawnvp(P_WAIT, exename, (char *const *)argv);
+	    free(exename);
+	}
+	else
+        exitcode = spawnvp(P_WAIT, a, (char *const *)argv);
 #else
 	if ((p = myfork()) == 0) {
 		myexecvp(a, argv);	/* child */
@@ -94,7 +107,7 @@ execute(char *a, ...)	/* note: "exec" is already defined on u370 */
 	
 	/* the menu and scrollbar may be changed by the command executed */
 #if UNIXPC || !TERMINFO
-# ifndef __DJGPP__ /* leave CRLF handling as is */      
+# if !defined(__DJGPP__) && !defined(WIN32)/* leave CRLF handling as is */      
 	nonl();
 # endif
 	raw();	/* endwin() turns off cbreak mode so restore it */
@@ -106,7 +119,7 @@ execute(char *a, ...)	/* note: "exec" is already defined on u370 */
 	return(exitcode);
 }
 
-#ifndef __MSDOS__ /* None of the following functions is used there */
+#if !defined(__MSDOS__) && !defined(WIN32) /* None of the following functions is used there */
 
 /* myexecvp is an interface to the execvp system call to
  * modify argv[0] to reference the last component of its path-name.
diff --git a/src/find.c b/src/find.c
index d7a66f0..216f653 100644
--- a/src/find.c
+++ b/src/find.c
@@ -35,6 +35,8 @@
  *	searching functions
  */
 
+#include "w32utils.h"
+
 #include "global.h"
 
 #include "build.h"
@@ -612,7 +614,8 @@ findfile(char *dummy)
 	} else {
 	    s = srcfiles[i];
 	}
-	if (regexec (&regexp, s, (size_t)0, NULL, 0) == 0) {
+	if (regexec (&regexp, s, (size_t)0, NULL, 0) == 0
+		|| regexec(&regexp, get_longpath(s), (size_t)0, NULL, 0) == 0) {
 	    (void) fprintf(refsfound, "%s <unknown> 1 <unknown>\n", 
 			   srcfiles[i]);
 	}
diff --git a/src/global.h b/src/global.h
index dbc8a43..e307059 100644
--- a/src/global.h
+++ b/src/global.h
@@ -245,6 +245,7 @@ extern	BOOL	kernelmode;	/* don't use DFLT_INCDIR - bad for kernels */
 extern	BOOL	linemode;	/* use line oriented user interface */
 extern	BOOL	verbosemode;	/* print extra information on line mode */
 extern	BOOL	recurse_dir;	/* recurse dirs when searching for src files */
+extern  BOOL	whitespace_safe;/* allow using whitespace in filenames */
 extern	char	*namefile;	/* file of file names */
 extern	BOOL	ogs;		/* display OGS book and subsystem names */
 extern	char	*prependpath;	/* prepend path to file names */
diff --git a/src/input.c b/src/input.c
index a8d6dea..119bfe2 100644
--- a/src/input.c
+++ b/src/input.c
@@ -90,18 +90,27 @@ mygetch(void)
 	    prevchar = 0;
 	} else {
 	    c = -1;
+#if defined(WIN32) && defined(__PDCURSES__)
+		    do {
+			c = getch();	/* get a character from the terminal */
+		    } while(!c || 
+			    c==KEY_SHIFT_L || c==KEY_SHIFT_R || 
+			    c==KEY_CONTROL_L || c==KEY_CONTROL_R ||
+			    c==KEY_ALT_L || c==KEY_ALT_R); /* Fix garbage with PDCurses */
+#else
 	    while (c == -1) {
 		/* get a character from the terminal */
 		c = getch();
 		if ((c == -1) && (errno != EINTR))
 		    break;
 	    }
+#endif
+	}
+	} else {	/* longjmp to here from signal handler */
+		c = KEY_BREAK;
 	}
-    } else {	/* longjmp to here from signal handler */
-	c = KEY_BREAK;
-    }
     signal(SIGINT, savesig);
-    return(c);
+	return(c);
 }
 
 
diff --git a/src/main.c b/src/main.c
index d28271c..5fcf320 100644
--- a/src/main.c
+++ b/src/main.c
@@ -58,7 +58,12 @@
 #endif
 
 /* defaults for unset environment variables */
+#ifdef WIN32
+/* there are no plain vanilla vi for Windows */
+#define EDITOR "vim"
+#else
 #define	EDITOR	"vi"
+#endif
 #define HOME	"/"	/* no $HOME --> use root directory */
 #define	SHELL	"sh"
 #define LINEFLAG "+%s"	/* default: used by vi and emacs */
@@ -96,6 +101,7 @@ BOOL	kernelmode;		/* don't use DFLT_INCDIR - bad for kernels */
 BOOL	linemode = NO;		/* use line oriented user interface */
 BOOL	verbosemode = NO;	/* print extra information on line mode */
 BOOL	recurse_dir = NO;	/* recurse dirs when searching for src files */
+BOOL	whitespace_safe = YES;  /* allow using whitespace in filenames */
 BOOL	remove_symfile_onexit=NO;
 char	*namefile;		/* file of file names */
 BOOL	ogs;			/* display OGS book and subsystem names */
@@ -124,7 +130,7 @@ static	void	usage(void);
 void	fixkeypad();
 #endif
 
-#if defined(KEY_RESIZE) && !defined(__DJGPP__)
+#if defined(KEY_RESIZE) && !defined(__DJGPP__) && !defined(WIN32)
 void 
 sigwinch_handler(int sig, siginfo_t *info, void *unused)
 {
@@ -297,10 +303,11 @@ main(int argc, char **argv)
     unsigned int i;
     pid_t pid;
     struct stat	stat_buf;
-#if defined(KEY_RESIZE) && !defined(__DJGPP__)
+#if defined(KEY_RESIZE) && !defined(__DJGPP__) && !defined(WIN32)
     struct sigaction winch_action;
 #endif
     mode_t orig_umask;
+    static char *signature;
 	
     yyin = stdin;
     yyout = stdout;
@@ -403,6 +410,9 @@ cscope: pattern too long, cannot be > %d characters\n", PATLEN);
 		case 'X':
 		remove_symfile_onexit = YES;
 		break;
+		case 'w':
+		whitespace_safe = NO;	
+		break;
 	    case 'f':	/* alternate cross-reference file */
 	    case 'F':	/* symbol reference lines file */
 	    case 'i':	/* file containing file names */
@@ -485,11 +495,27 @@ cscope: reffile too long, cannot be > %d characters\n", sizeof(path) - 3);
     editor = mygetenv("EDITOR", EDITOR);
     editor = mygetenv("VIEWER", editor); /* use viewer if set */
     editor = mygetenv("CSCOPE_EDITOR", editor);	/* has last word */
+#ifndef WIN32
     home = mygetenv("HOME", HOME);
+#else
+	home = mygetenv("HOME", NULL);
+	if (home==NULL)
+	    home = mygetenv("USERPROFILE", HOME);
+#endif
     shell = mygetenv("SHELL", SHELL);
     lineflag = mygetenv("CSCOPE_LINEFLAG", LINEFLAG);
     lineflagafterfile = getenv("CSCOPE_LINEFLAG_AFTER_FILE") ? 1 : 0;
+#ifndef WIN32
     tmpdir = mygetenv("TMPDIR", TMPDIR);
+#else
+	tmpdir = mygetenv("TMPDIR", NULL);
+	if (tmpdir==NULL)
+	{
+	    tmpdir = mygetenv("TEMP", NULL);
+	    if (tmpdir==NULL)
+		tmpdir = mygetenv("TMP", TMPDIR);
+	}
+#endif
 
     /* XXX remove if/when clearerr() in dir.c does the right thing. */
     if (namefile && strcmp(namefile, "-") == 0 && !buildonly) {
@@ -509,16 +535,24 @@ cscope: TMPDIR to a valid directory\n");
     }
 
     /* create the temporary file names */
+#ifndef WIN32
     orig_umask = umask(S_IRWXG|S_IRWXO);
+#endif
     pid = getpid();
     snprintf(tempdirpv, sizeof(tempdirpv), "%s/cscope.%d", tmpdir, pid);
-    if(mkdir(tempdirpv,S_IRWXU)) {
+    if(mkdir(tempdirpv
+#ifndef WIN32
+		,S_IRWXU
+#endif
+		)) {
 	fprintf(stderr, "\
 cscope: Could not create private temp dir %s\n",
 		tempdirpv);
 	myexit(1);
     }
+#ifndef WIN32
     umask(orig_umask);
+#endif
 
     snprintf(temp1, sizeof(temp1), "%s/cscope.1", tempdirpv);
     snprintf(temp2, sizeof(temp2), "%s/cscope.2", tempdirpv);
@@ -527,10 +561,14 @@ cscope: Could not create private temp dir %s\n",
     if (signal(SIGINT, SIG_IGN) != SIG_IGN) {
 	/* cleanup on the interrupt and quit signals */
 	signal(SIGINT, myexit);
+#ifndef WIN32
 	signal(SIGQUIT, myexit);
+#endif
     }
+#ifndef WIN32
     /* cleanup on the hangup signal */
     signal(SIGHUP, myexit);
+#endif
 
     /* ditto the TERM signal */
     signal(SIGTERM, myexit);
@@ -539,10 +577,16 @@ cscope: Could not create private temp dir %s\n",
      * linemode, while in curses mode the "|" command can cause a pipe signal
      * too
      */
+#ifdef SIGPIPE
     signal(SIGPIPE, SIG_IGN);
+#endif
 
     /* if the database path is relative and it can't be created */
-    if (reffile[0] != '/' && access(".", WRITE) != 0) {
+    if (reffile[0] != '/' 
+#ifdef WIN32
+		&& reffile[0] != '\\' && reffile[1] != ':' 
+#endif
+		&& access(".", WRITE) != 0) {
 
 	/* put it in the home directory if the database may not be
 	 * up-to-date or doesn't exist in the relative directory,
@@ -562,8 +606,11 @@ cscope: Could not create private temp dir %s\n",
 
     if (linemode == NO) {
 	signal(SIGINT, SIG_IGN);	/* ignore interrupts */
+#ifdef SIGPIPE
+	signal(SIGPIPE, SIG_IGN);/* | command can cause pipe signal */
+#endif
 
-#if defined(KEY_RESIZE) && !defined(__DJGPP__)
+#if defined(KEY_RESIZE) && !defined(__DJGPP__) && !defined(WIN32)
 	winch_action.sa_sigaction = sigwinch_handler;
 	sigemptyset(&winch_action.sa_mask);
 	winch_action.sa_flags = SA_SIGINFO;
@@ -595,12 +642,17 @@ cscope: Could not create private temp dir %s\n",
 	    postfatal("cscope: cannot open file %s\n", reffile);
 	    /* NOTREACHED */
 	}
+	signature = (whitespace_safe
+	   ? "cscope %d %*[^\"]s"
+	   : "cscope %d %*s");
 	/* get the crossref file version but skip the current directory */
-	if (fscanf(oldrefs, "cscope %d %*s", &fileversion) != 1) {
+	if (fscanf(oldrefs, signature, &fileversion) != 1) {
 	    postfatal("cscope: cannot read file version from file %s\n", 
 		      reffile);
 	    /* NOTREACHED */
 	}
+	if (whitespace_safe)
+	    fgetc(oldrefs); /* remove the mark */
 	if (fileversion >= 8) {
 
 	    /* override these command line options */
@@ -961,8 +1013,8 @@ skiplist(FILE *oldrefs)
 void
 entercurses(void)
 {
-    incurses = YES;
-#ifndef __MSDOS__ /* HBB 20010313 */
+	incurses = YES;
+#if !defined(__MSDOS__) && !defined(WIN32) /* HBB 20010313 */
     nonl();		    /* don't translate an output \n to \n\r */
 #endif
     raw();			/* single character input */
@@ -1004,7 +1056,7 @@ error_usage(void)
 static void
 usage(void)
 {
-	fprintf(stderr, "Usage: cscope [-bcCdehklLqRTuUvV] [-f file] [-F file] [-i file] [-I dir] [-s dir]\n");
+	fprintf(stderr, "Usage: cscope [-bcCdehklLqRTuUvVX] [-f file] [-F file] [-i file] [-I dir] [-s dir]\n");
 	fprintf(stderr, "              [-p number] [-P path] [-[0-8] pattern] [source files]\n");
 }
 
@@ -1046,6 +1098,7 @@ longusage(void)
 -u            Unconditionally build the cross-reference file.\n\
 -v            Be more verbose in line mode.\n\
 -V            Print the version number.\n\
+-X            Keep database format compatible with original cscope.\n\
 \n\
 Please see the manpage for more information.\n",
 	      stderr);
@@ -1071,10 +1124,12 @@ myexit(int sig)
 	if (incurses == YES) {
 		exitcurses();
 	}
+#ifndef WIN32
 	/* dump core for debugging on the quit signal */
 	if (sig == SIGQUIT) {
 		abort();
 	}
+#endif
 	/* HBB 20000421: be nice: free allocated data */
 	freefilelist();
 	freeinclist();
diff --git a/src/mypopen.c b/src/mypopen.c
index b1601d8..713778a 100644
--- a/src/mypopen.c
+++ b/src/mypopen.c
@@ -34,7 +34,9 @@
 #include <signal.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifndef WIN32
 #include <sys/wait.h>
+#endif
 #include "global.h"	/* pid_t, shell, and mybasename() */
 
 #define	tst(a,b) (*mode == 'r'? (b) : (a))
@@ -73,12 +75,12 @@ myopen(char *path, int flag, int mode)
     else
 	fd = open(path, flag);
 
-#ifdef __DJGPP__		/* FIXME: test feature, not platform */
+#if defined(__DJGPP__) || defined(WIN32)	/* FIXME: test feature, not platform */
     /* HBB 20010312: DOS GCC doesn't have FD_CLOEXEC (yet), so it 
      * always fails this call. Have to skip that step */
     if(fd != -1)
 	return(fd);
-#endif
+#else
     if(fd != -1 && (fcntl(fd, F_SETFD, CLOSE_ON_EXEC) != -1))
 	return(fd);
 
@@ -94,6 +96,7 @@ myopen(char *path, int flag, int mode)
 
 	    return(-1);
 	}
+#endif
 }
 
 FILE *
@@ -110,7 +113,7 @@ myfopen(char *path, char *mode)
     }
 #endif /* SETMODE */
 	
-#ifdef __DJGPP__ /* FIXME: test feature, not platform */
+#if defined(__DJGPP__) || defined(WIN32) /* FIXME: test feature, not platform */
     /* HBB 20010312: DOS GCC doesn't have FD_CLOEXEC (yet), so it 
      * always fails this call. Have to skip that step */
     if(fp)
@@ -129,7 +132,7 @@ myfopen(char *path, char *mode)
 FILE *
 mypopen(char *cmd, char *mode)
 {
-#ifdef __DJGPP__
+#if defined(__DJGPP__) || defined(WIN32)
 	/* HBB 20010312: Has its own implementation of popen(), which
 	 * is better suited to the platform than cscope's */
 	return (popen)(cmd, mode);
@@ -178,7 +181,7 @@ mypopen(char *cmd, char *mode)
 int
 mypclose(FILE *ptr)
 {
-#ifdef __DJGPP__ 
+#if defined(__DJGPP__) || defined(WIN32)
 	/* HBB 20010705: This system has its own pclose(), which we
 	 * don't want to replace */
 	return (pclose)(ptr);
diff --git a/src/vpaccess.c b/src/vpaccess.c
index d8c8be7..9576a72 100644
--- a/src/vpaccess.c
+++ b/src/vpaccess.c
@@ -44,7 +44,11 @@ vpaccess(char *path, mode_t amode)
 	int	returncode;
 	int	i;
 
-	if ((returncode = access(path, amode)) == -1 && path[0] != '/') {
+	if ((returncode = access(path, amode)) == -1 && path[0] != '/'
+#ifdef WIN32
+		&& path[0] != '\\' && path[1] != ':'
+#endif
+		) {
 		vpinit(NULL);
 		for (i = 1; i < vpndirs; i++) {
 			(void) snprintf(buf, sizeof(buf), "%s/%s", vpdirs[i], path);
diff --git a/src/vpfopen.c b/src/vpfopen.c
index b236864..3da1a5a 100644
--- a/src/vpfopen.c
+++ b/src/vpfopen.c
@@ -46,6 +46,9 @@ vpfopen(char *filename, char *type)
 
 	if ((returncode = myfopen(filename, type)) == NULL 
 		&& filename[0] != '/' 
+#ifdef WIN32
+		&& filename[0] != '\\' && filename[1] != ':' 
+#endif
 		/* && strcmp(type, "r") == 0 */ /* HBB: this breaks if type=="rb" */
 		&& type[0] == 'r'
 		) {
diff --git a/src/vpinit.c b/src/vpinit.c
index ad15af7..c6cd96d 100644
--- a/src/vpinit.c
+++ b/src/vpinit.c
@@ -36,6 +36,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#ifdef MSVC_WIN32
+#include <direct.h>	/* getcwd */
+#endif
 #include "vp.h"
 #include "alloc.h"
 #include "library.h"
@@ -88,8 +91,15 @@ vpinit(char *current_dir)
 	for (i = 0; vpath[i] == current_dir[i] && vpath[i] != '\0'; ++i) {
 		;
 	}
+
+#ifdef WIN32
+	if ((vpath[i] != ';' && vpath[i] != '\0') ||
+	    (current_dir[i] != '/' && current_dir[i] != '\0' && current_dir[i] != '\\'))
+#else
 	if ((vpath[i] != ':' && vpath[i] != '\0') ||
-	    (current_dir[i] != '/' && current_dir[i] != '\0')) {
+	    (current_dir[i] != '/' && current_dir[i] != '\0'))
+#endif
+	{
 		return;
 	}
 	suffix = &current_dir[i];
@@ -98,7 +108,12 @@ vpinit(char *current_dir)
 	/* count the nodes in the view path */
 	vpndirs = 1;
 	for (i = 0; vpath[i] != '\0'; ++i) {
-		if (vpath[i] == ':' && vpath[i + 1]) {
+#ifdef WIN32
+		if (vpath[i] == ';'
+#else
+		if (vpath[i] == ':' 
+#endif
+			&& vpath[i + 1]) {
 			++vpndirs;
 		}
 	}
@@ -111,7 +126,13 @@ vpinit(char *current_dir)
 	/* split the view path into nodes */
 	for (i = 0, s = vpath; *s != '\0'; ++i) {
 		vpdirs[i] = s;
-		while (*s != '\0' && *++s != ':') {
+		while (*s != '\0' &&
+#ifdef WIN32
+			*++s != ';'
+#else
+			*++s != ':'
+#endif
+			) {
 			if (*s == '\n') {
 				*s = '\0';
 			}
@@ -142,7 +163,13 @@ vpinit(char *current_dir)
 		
 		/* get the next node */
 		node = s;
-		while (*s != '\0' && *++s != ':') {
+		while (*s != '\0' && 
+#ifdef WIN32
+			*++s != ';'
+#else
+			*++s != ':'
+#endif
+			) {
 			if (*s == '\n') {
 				*s = '\0';
 			}
diff --git a/src/vpopen.c b/src/vpopen.c
index 8eac788..065151d 100644
--- a/src/vpopen.c
+++ b/src/vpopen.c
@@ -47,6 +47,9 @@ vpopen(char *path, int oflag)
 	int	i;
 
 	if ((returncode = myopen(path, oflag, 0666)) == -1 && path[0] != '/' &&
+#ifdef WIN32
+		path[0] != '\\' && path[1] != ':' &&
+#endif
 	    oflag == OPENFLAG_READ) {
 		vpinit(NULL);
 		for (i = 1; i < vpndirs; i++) {
diff --git a/src/w32utils.c b/src/w32utils.c
new file mode 100644
index 0000000..badd199
--- /dev/null
+++ b/src/w32utils.c
@@ -0,0 +1,78 @@
+#include "w32utils.h"
+
+#ifdef WIN32
+
+#define WIN32_LEAN_AND_MEAN
+#define VC_EXTRALEAN
+
+/* for GetLongPathName */
+#define _WIN32_WINDOWS 0x0410
+
+#include <windows.h>
+
+#include "alloc.h"
+
+static char *get_longpath_internal(char *path, int len);
+
+char *get_shortpath(char *path)
+{
+    if (strchr(path, ' ') == NULL) /* get short name only for files with spaces in names */
+	return path;
+    else
+    {
+	/* use satic buffers for simplicity */
+	static char short_path[MAX_PATH + 1];
+	int ret = GetShortPathName(path, short_path, sizeof(short_path));
+	if (!ret || ret > sizeof(short_path))
+	    /* error during the conversion */
+	    return path;
+	return short_path;
+    }
+}
+
+void to_longpath(char *path, int len)
+{
+    char *long_path = get_longpath_internal(path, len);
+    if (long_path != path)
+	/* get_longpath_internal gurantees result will be no longer than len */
+	strcpy(path, long_path);
+}
+
+char *get_longpath(char *path)
+{
+    return get_longpath_internal(path, -1);
+}
+
+static char *get_longpath_internal(char *path, int len)
+{
+    static char long_path[MAX_PATH + 1];
+    int buflen;
+    buflen = (len == -1 ? sizeof(long_path) : len);
+    int ret = GetLongPathName(path, long_path, buflen);
+    if (!ret || ret > buflen)
+	/* error during the conversion */
+	return path;
+    return long_path;
+}
+
+void sleep_w32(int sec)
+{
+    Sleep(sec * 1000);
+}
+
+#else
+char *get_shortpath(char *path)
+{
+    return path;
+}
+
+void to_longpath(char *path, int len)
+{
+    NULL;
+}
+
+char *get_longpath(char *path)
+{
+    return path;
+}
+#endif /* WIN32 */
diff --git a/src/w32utils.h b/src/w32utils.h
new file mode 100644
index 0000000..e82407b
--- /dev/null
+++ b/src/w32utils.h
@@ -0,0 +1,13 @@
+#ifndef CSCOPE_W32UTILS_H
+# define CSCOPE_W32UTILS_H
+
+char *get_shortpath(char *path);
+char *get_longpath(char *path);
+/*in-place conversion */
+void to_longpath(char *path, int len);
+
+# ifdef WIN32
+void sleep_w32(int sec);
+# endif
+
+#endif /* CSCOPE_W32UTILS_H */
