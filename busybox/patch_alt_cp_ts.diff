diff --git a/archival/dpkg.c b/archival/dpkg.c
index 6f28b99..552e6c2 100644
--- a/archival/dpkg.c
+++ b/archival/dpkg.c
@@ -421,6 +421,50 @@ static void add_edge_to_node(common_node_t *node, edge_t *edge)
 	node->edge[node->num_of_edges++] = edge;
 }
 
+#define strtok_r strtok_r_static
+/* 
+ * public domain strtok_r() by Charlie Gordon
+ *
+ *   from comp.lang.c  9/14/2007
+ *
+ *      http://groups.google.com/group/comp.lang.c/msg/2ab1ecbb86646684
+ *
+ *     (Declaration that it's public domain):
+ *      http://groups.google.com/group/comp.lang.c/msg/7c7b39328fefab9c
+ */
+static char* strtok_r(
+    char *str, 
+    const char *delim, 
+    char **nextp)
+{
+    char *ret;
+
+    if (str == NULL)
+    {
+        str = *nextp;
+    }
+
+    str += strspn(str, delim);
+
+    if (*str == '\0')
+    {
+        return NULL;
+    }
+
+    ret = str;
+
+    str += strcspn(str, delim);
+
+    if (*str)
+    {
+        *str++ = '\0';
+    }
+
+    *nextp = str;
+
+    return ret;
+}
+
 /*
  * Create one new node and one new edge for every dependency.
  *
diff --git a/miscutils/bc.c b/miscutils/bc.c
index c7246ea..33f8e2e 100644
--- a/miscutils/bc.c
+++ b/miscutils/bc.c
@@ -7390,7 +7390,7 @@ static int xc_vm_init(const char *env_len)
 //TODO: in GNU bc, the check is (isatty(0) && isatty(1)),
 //-i option unconditionally enables this regardless of isatty():
 	if (isatty(0)) {
-#if ENABLE_FEATURE_BC_INTERACTIVE
+#if 0 && ENABLE_FEATURE_BC_INTERACTIVE
 		G_ttyin = 1;
 		// With SA_RESTART, most system calls will restart
 		// (IOW: they won't fail with EINTR).
diff --git a/miscutils/ts.c b/miscutils/ts.c
index f2d3676..3bbd6b4 100644
--- a/miscutils/ts.c
+++ b/miscutils/ts.c
@@ -52,6 +52,7 @@ int ts_main(int argc UNUSED_PARAM, char **argv)
 	while ((line = xmalloc_fgets(stdin)) != NULL) {
 		struct timeval ts;
 		struct tm tm_time;
+        time_t t;
 
 		gettimeofday(&ts, NULL);
 		if (opt) {
@@ -70,7 +71,8 @@ int ts_main(int argc UNUSED_PARAM, char **argv)
 			if (opt & 1) /* -i */
 				base = ts1;
 		}
-		localtime_r(&ts.tv_sec, &tm_time);
+        t = ts.tv_sec;
+		localtime_r(&t, &tm_time);
 		strftime(date_buf, COMMON_BUFSIZE, fmt_dt2str, &tm_time);
 		if (!frac) {
 			printf("%s %s", date_buf, line);
diff --git a/networking/wget.c b/networking/wget.c
index 4365c76..9151a16 100644
--- a/networking/wget.c
+++ b/networking/wget.c
@@ -1235,6 +1235,22 @@ static void download_one_url(const char *url)
 		}
 
 		if (option_mask32 & WGET_OPT_POST_DATA) {
+			int fd = -1;
+			off_t len = 0;
+			if (G.post_data[0] == '@') {
+				fd = open(G.post_data + 1, O_RDONLY);
+				if (fd >= 0) {
+#if defined(__MINGW64_VERSION_MAJOR)
+					_setmode(fd, _O_BINARY);
+#endif
+					len = lseek(fd, 0, SEEK_END);
+					if (len < 0 || lseek(fd, 0, SEEK_SET) < 0) {
+						close(fd);
+						fd = -1;
+					}
+				}
+			}
+			if (fd < 0)
 			SENDFMT(sfp,
 				"Content-Type: application/x-www-form-urlencoded\r\n"
 				"Content-Length: %u\r\n"
@@ -1242,6 +1258,30 @@ static void download_one_url(const char *url)
 				"%s",
 				(int) strlen(G.post_data), G.post_data
 			);
+			else {
+				char buf[CONFIG_FEATURE_COPYBUF_KB*1024] ALIGNED(16);
+				if ((len >> 32) == 0)
+					SENDFMT(sfp,
+							"Content-Type: application/x-www-form-urlencoded\r\n"
+							"Content-Length: %u\r\n"
+							"\r\n",
+							(unsigned) len);
+				else
+					SENDFMT(sfp,
+							"Content-Type: application/x-www-form-urlencoded\r\n"
+							"Content-Length: %u%09u\r\n"
+							"\r\n",
+							(unsigned) (len / 1000000000),
+							(unsigned) (len % 1000000000));
+				while (len) {
+					off_t r = read(fd, buf, sizeof(buf));
+					if (r <= 0)
+						break;
+					fwrite(buf, 1, r, sfp);
+					len -= r;
+				}
+				close(fd);
+			}
 		} else
 #endif
 		{
diff --git a/win32/mingw.c b/win32/mingw.c
index 38fbf2d..c7c59c9 100644
--- a/win32/mingw.c
+++ b/win32/mingw.c
@@ -1301,6 +1301,40 @@ int mingw_unlink(const char *pathname)
 	return unlink(pathname);
 }
 
+static int is_leap(int y)
+{
+	/* Avoid overflow */
+	if (y>INT_MAX-1900) y -= 2000;
+	y += 1900;
+	return !(y%4) && ((y%100) || !(y%400));
+}
+
+static int week_num(const struct tm *tm)
+{
+	int val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
+	/* If 1 Jan is just 1-3 days past Monday,
+	 * the previous week is also in this year. */
+	if ((tm->tm_wday + 371U - tm->tm_yday - 2) % 7 <= 2)
+		val++;
+	if (!val) {
+		/* If 31 December of prev year a Thursday,
+		 * or Friday of a leap year, then the
+		 * prev year has 53 weeks. */
+		int dec31 = (tm->tm_wday + 7U - tm->tm_yday - 1) % 7;
+		val = 52;
+		if (dec31 == 4 || (dec31 == 5 && is_leap(tm->tm_year%400-1)))
+			val++;
+	} else if (val == 53) {
+		/* If 1 January is not a Thursday, and not
+		 * a Wednesday of a leap year, then this
+		 * year has only 52 weeks. */
+		int jan1 = (tm->tm_wday + 371U - tm->tm_yday) % 7;
+		if (jan1 != 4 && (jan1 != 3 || !is_leap(tm->tm_year)))
+			val = 1;
+	}
+	return val;
+}
+
 #undef strftime
 size_t mingw_strftime(char *buf, size_t max, const char *format, const struct tm *tm)
 {
@@ -1368,6 +1402,30 @@ size_t mingw_strftime(char *buf, size_t max, const char *format, const struct tm
 				/* Microsoft uses '#' rather than '-' to remove padding */
 				t[1] = '#';
 			}
+			else if ( t[1] == 'g' || t[1] == 'G' || (t[1] == '-' && (
+									t[2] == 'g' || t[2] == 'G')) ) {
+				int width = 2;
+				int val = tm->tm_year + 1900;
+				if (tm->tm_yday < 3 && week_num(tm) != 1) val--;
+				else if (tm->tm_yday > 360 && week_num(tm) == 1) val++;
+				if (t[1] == 'g' || (t[1] == '-' && t[2] == 'g')) val %= 100;
+				else width = 4;
+				if (t[1] == '-') {
+					sprintf(buffer, "%d", val);
+				} else {
+					sprintf(buffer, "%0*d", width, val);
+				}
+				replace = buffer;
+			}
+			else if ( t[1] == 'V' || (t[1] == '-' && t[2] == 'V') ) {
+				int val = week_num(tm);
+				if (t[1] == '-') {
+					sprintf(buffer, "%d", val);
+				} else {
+					sprintf(buffer, "%02d", val);
+				}
+				replace = buffer;
+			}
 			else if ( t[1] != '\0' ) {
 				++t;
 			}
@@ -1378,6 +1436,9 @@ size_t mingw_strftime(char *buf, size_t max, const char *format, const struct tm
 
 				*t = '\0';
 				m = t - fmt;
+				if ( t[1] == '-' ) {
+					++t;
+				}
 				newfmt = xasprintf("%s%s%s", fmt, replace, t+2);
 				free(fmt);
 				t = newfmt + m + strlen(replace);
diff --git a/win32/termios.c b/win32/termios.c
index 25f2ea4..a5c5473 100644
--- a/win32/termios.c
+++ b/win32/termios.c
@@ -19,6 +19,15 @@ int64_t FAST_FUNC read_key(int fd, char *buf UNUSED_PARAM, int timeout)
 		bb_error_msg_and_die("read_key only works on stdin");
 	if (cin == INVALID_HANDLE_VALUE)
 		return -1;
+#if ENABLE_FEATURE_EURO
+    if (buf[0]) { // 2-byte char sequence
+        ret = (unsigned char) buf[1];
+        buf[0] = buf[1] = 0;
+        return ret;
+    }
+#else
+    (void) buf;
+#endif
 	GetConsoleMode(cin, &mode);
 	SetConsoleMode(cin, 0);
 
@@ -61,14 +70,15 @@ int64_t FAST_FUNC read_key(int fd, char *buf UNUSED_PARAM, int timeout)
 				case VK_END:
 				case VK_DOWN:
 				case VK_NEXT:
-				case VK_LEFT:
 				case VK_CLEAR:
-				case VK_RIGHT:
 				case VK_HOME:
 				case VK_UP:
 				case VK_PRIOR:
 				case VK_KANA:
 					continue;
+				case VK_LEFT: ret = KEYCODE_ALT_LEFT; goto done;
+				case VK_RIGHT: ret = KEYCODE_ALT_RIGHT; goto done;
+				case VK_DELETE: ret = KEYCODE_ALT_D; goto done;
 				}
 			}
 
@@ -102,7 +112,20 @@ int64_t FAST_FUNC read_key(int fd, char *buf UNUSED_PARAM, int timeout)
 		uchar = record.Event.KeyEvent.uChar.UnicodeChar;
 		achar = uchar & 0x7f;
 		if (achar != uchar)
+#if 0
 			WideCharToMultiByte(CP_ACP, 0, &uchar, 1, &achar, 1, NULL, NULL);
+#else
+        {
+            int n = WideCharToMultiByte(CP_ACP, 0, &uchar, 1, buf, 2, NULL, NULL);;
+            if (n < 2) {
+                ret = buf[0] ? (unsigned char) buf[0] : achar;
+                buf[0] = buf[1] = 0;
+            } else {
+                ret = (unsigned char) buf[0];
+            }
+        }
+        else
+#endif
 		ret = achar;
 #else
 		if ( (record.Event.KeyEvent.uChar.AsciiChar & 0x80) == 0x80 ) {
@@ -111,6 +134,16 @@ int64_t FAST_FUNC read_key(int fd, char *buf UNUSED_PARAM, int timeout)
 		}
 		ret = record.Event.KeyEvent.uChar.AsciiChar;
 #endif
+        if (alt_pressed) {
+            switch (ret)
+            {
+				case '\t': continue;
+				case '\b': ret = KEYCODE_ALT_BACKSPACE; goto done;
+				case 'd': ret = KEYCODE_ALT_D; goto done;
+				case 'f': ret = KEYCODE_ALT_RIGHT; goto done;
+				case 'b': ret = KEYCODE_ALT_LEFT; goto done;
+            }
+        }
 		break;
 	}
  done:
diff --git a/win32/winansi.c b/win32/winansi.c
index 41ca3cc..d8ac0f6 100644
--- a/win32/winansi.c
+++ b/win32/winansi.c
@@ -463,6 +463,7 @@ static BOOL winansi_CharToOemBuff(LPCSTR s, LPSTR d, DWORD len)
 
 	if (!s || !d)
 		return FALSE;
+    i = (unsigned char) *s;
 
 	buf = xmalloc(len*sizeof(WCHAR));
 	MultiByteToWideChar(CP_ACP, 0, s, len, buf, len);
@@ -474,6 +475,9 @@ static BOOL winansi_CharToOemBuff(LPCSTR s, LPSTR d, DWORD len)
 			}
 		}
 	}
+    else if (len == 1 && d[0] == '?' && GetOEMCP() > 874) {
+        d[0] = i;
+    }
 	free(buf);
 	return TRUE;
 }
